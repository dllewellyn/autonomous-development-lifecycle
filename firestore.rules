
/**
 * This ruleset enforces a strict user-ownership security model for the YieldAssure application.
 * The core philosophy is that all data is private to the user who created it, and no data
 * is publicly readable or writable by default.
 *
 * Core Philosophy:
 * - A user can only access data that exists under their own user ID path.
 * - This is achieved by consistently matching the `request.auth.uid` against the `userId`
 *   wildcard in the document path.
 *
 * Data Structure:
 * - All application data is nested hierarchically under the `/users/{userId}` collection.
 * - A user's profile is stored at `/users/{userId}`.
 * - A user's linked banking accounts are stored in a subcollection:
 *   `/users/{userId}/open_banking_accounts/{accountId}`.
 *
 * Key Security Decisions:
 * - User Enumeration is Disallowed: Listing the top-level `/users` collection is explicitly
 *   forbidden to prevent attackers from discovering all users of the application.
 * - Self-Creation of Profiles: A newly signed-in user is permitted to create their own
 *   user profile document, but cannot create one for anyone else.
 * - Path-Based Authorization: All authorization decisions are made using the `userId`
 *   from the document path, which avoids slow and costly `get()` calls to other documents.
 * - Relational Integrity: On document creation, rules ensure that internal ID fields
 *   (like `userId` or `firebaseUid`) correctly match the path, establishing a secure
 * and consistent ownership link. These fields are then enforced as immutable on updates.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions to promote readable and reusable logic.

    /**
     * Checks if a user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the currently authenticated user's UID matches the given userId.
     * This is the primary function for enforcing user ownership.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Checks for ownership on an existing document. Used for update and delete
     * operations to prevent acting on documents that do not exist.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }
    
    /**
     * @description Rules for a user's own account document.
     * @path /users/{userId}
     * @allow (create) An authenticated user can create their own UserAccount document.
     * @deny  (list) A user cannot list all documents in the `/users` collection.
     * @principle Restricts access to a user's own data tree and prevents user enumeration.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false; // CRITICAL: Prevents listing all users in the application.
      
      // Combined create and update logic for robust `set` with merge operations.
      allow write: if isOwner(userId) && (
                    // Create Operation: Allow if creating for the first time.
                    // This handles both full profile creation and the "skip" flow which only writes onboardingComplete.
                    (request.method == 'create' && (
                        (request.resource.data.id == userId && request.resource.data.firebaseUid == request.auth.uid) ||
                        ('onboardingComplete' in request.resource.data && request.resource.data.keys().size() == 1)
                    )) ||
                    // Update Operation: Allow if document exists and immutable fields are not changed.
                    (request.method == 'update' &&
                      (!('id' in request.resource.data) || request.resource.data.id == resource.data.id) &&
                      (!('firebaseUid' in request.resource.data) || request.resource.data.firebaseUid == resource.data.firebaseUid)
                    )
                  );
                  
      allow delete: if isExistingOwner(userId);

      /**
       * @description Rules for a user's collection of linked Open Banking accounts.
       * @path /users/{userId}/open_banking_accounts/{accountId}
       * @allow (create) The user can create a new OpenBankingAccount document within their own subcollection.
       * @deny  (get) An authenticated user cannot get an OpenBankingAccount belonging to another user.
       * @principle Enforces path-based ownership for all nested user data.
       */
      match /open_banking_accounts/{accountId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId) && request.resource.data.userId == userId;
        allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
        allow delete: if isExistingOwner(userId);
      }

      /**
       * @description Rules for a user's collection of linked Monzo accounts.
       * @path /users/{userId}/monzo_accounts/{accountId}
       */
      match /monzo_accounts/{accountId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId) && request.resource.data.userId == userId;
        allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
        allow delete: if isExistingOwner(userId);
      }

      /**
       * @description Rules for a user's collection of Monzo pots.
       * @path /users/{userId}/monzo_pots/{potId}
       */
      match /monzo_pots/{potId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId) && request.resource.data.userId == userId;
        allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
        allow delete: if isExistingOwner(userId);
      }

      /**
       * @description Rules for a user's direct debits.
       * @path /users/{userId}/user_direct_debits/{directDebitId}
       */
      match /user_direct_debits/{directDebitId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId) && request.resource.data.userId == userId;
        allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
        allow delete: if isExistingOwner(userId);
      }

      /**
       * @description Rules for a user's income profile.
       * @path /users/{userId}/user_income_profiles/{profileId}
       */
      match /user_income_profiles/{profileId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId) && request.resource.data.userId == userId;
        allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
        allow delete: if isExistingOwner(userId);
      }
      
      /**
       * @description Rules for a user's collection of chat messages.
       * @path /users/{userId}/messages/{messageId}
       * @allow The user can read and write to their own messages subcollection.
       * @principle Enforces path-based ownership for all chat data.
       */
      match /messages/{messageId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        // During onboarding, client can create system messages. Afterwards, only user messages.
        allow create: if isOwner(userId);
        allow update, delete: if false; // Messages are immutable
      }

      /**
       * @description Rules for a user's outgoing message queue.
       * @path /users/{userId}/send_message/{messageId}
       * @allow (create) The user can create a new message in the queue.
       * @allow (list/get) The user can see their queued messages.
       */
      match /send_message/{messageId} {
        allow create: if isOwner(userId);
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow update, delete: if false; 
      }
    }
  }
}
